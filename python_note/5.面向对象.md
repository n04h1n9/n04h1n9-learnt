# 面向对象

面向对象编程是一种非常流行的编程范式,
所谓编程范式就是程序设计的方法论，简单的说就是程序员对程序的认知和理解以及他们编写代码的方式。
在面向对象的世界里，程序中的数据和操作数据的函数是一个逻辑上的整体，被称为对象，对象可以接收消息，
解决问题的方法就是创建对象并向对象发各种各样的消息  

不说人话就是：把一组数据和处理数据的方法组成对象，把行为相同的对象归纳为类，通过封装隐藏对象的内部细节，通过继承实现类的特化和泛化，通过多态实现基于对象类型的动态分派

## 类和对象

类是抽象的概念，对象是具体的概念，把不同对象的共同特征抽象出来就是一个类。
面向对象中，一切皆为对象，对象皆有属性和行为，对象一定属于某个类，
面向对象编程的步骤大体上分为：定义类、创建对象、给对象发消息，以下是演示：

```python
class People: #用class关键字定义类，类名得用驼峰命名法
    def walk(self, road): #第一个参数一定是self
        print(f'在{road}上行走') #定义一个函数，该函数是这个类的所有对象都能调用的方法（行为特征）
    man = People() #创建对象，类、方法、函数后面要加圆括号
    #给对象发消息
man.walk(hyw) #walk是man对象的方法，这里通过对象.方法的形式调用方法（给对象发消息）
People.walk(man, hyw) #效果同上，这里通过类.方法的形式调用方法
```

## 初始化方法

以上代码的对象只有行为没有属性（man没有名字啊性别啊之类的），对象光有动作解决不了所有问题，
通过添加__init__方法为其提供属性，这个__init__方法叫初始化方法，演示如下：

```python
class People:
    def __init__(self, name): #初始化方法，其参数叫初始化参数
        self.n = name #self.n即为对象的属性，属性和方法不同，调用属性后面不用圆括号
    def walk(self, road):
        print(f'{self.n}在{road}上行走')
man = People('zj') #有了初始化参数，创建对象时就可以传入初始化参数作为对象的属性
print(man.walk(hyw)) #zj在hyw上行走
```

## 可见性和属性装饰器

对象的属性可以被设成私有的或受保护的（默认情况下是公开的），
这样使得属性不能在类的外面访问（类里面的方法是可以的），
以上代码中，可以通过`__name`设置一个私有属性，通过`_name`设置一个受保护属性，
这样的语法叫属性装饰器

但没必要设置可见性，
而且如果愿意的话，通过`man_Student__name`的方式仍然可以访问

## 动态属性

python是动态语言，在运行时可以为其添加新的东西。
这里可以给对象添加新的属性，
如上面的代码中，可以在后面添加`man.sex = True`为对象新增性别属性

如果不希望添加动态属性，则可以使用`__slots__`魔法（__xxx__叫魔法方法），用法见下：

```python
class People:
    __slots__ = ('n') #规定对象的属性只能有name
    def __init__(self, name):
        self.n = name
```

## 静态方法和类方法

对象可以接受消息，同样的，类本身也可以接受消息，即类也有自己的方法，
类可用的方法有类方法和静态方法，二者差不多，但细节上有些许差异，
以下以判断三边是否能组成三角形及计算三角形周长面积为例子，讲述两种方法

```python
# 定义类
class Calculate:
    # 初始化方法
    def __init__(self, a, b, c):
        self.a = a
        self.b = b
        self.c = c

    # 验证是否能组成
    @staticmethod #声明了is_sjx是Calculate类的静态方法
    def is_sjx(a, b, c):
        return a + b > c and a + c > b and b + c > a

    # @classmethod #声明类方法
    # def is_sjx(self, a, b, c): #类方法除语法糖跟这里定义多一个self外无区别，包括后面调用
    #     return a + b > c and a + c > b and b + c > a

    # 能组成三角形，并计算周长和面积
    def cal(self):
        # 这里传属性就行了，前面已经初始化好了
        if Calculate.is_sjx(self.a, self.b, self.c): #调用静态方法
            C = self.a + self.b + self.c
            p = C / 2
            S = (p * (p - self.a) * (p - self.b) * (p - self.c)) ** 0.5
            print(f"周长是：{C},面积是{S}")
        else:
            print("无法创建三角形")


# 创建对象
abc = Calculate(11, 45, 14)
xyz = Calculate(3, 4, 5)

# 使用对象
abc.cal()
xyz.cal()
```

## property装饰器（方法变属性）

不多说，演示如下：

```python
class Graphics:
    def __init__(self, a, b, c, d):
        self.a = a
        self.b = b
        self.c = c
        self.d = d
    @property #property装饰器，用于把对象的方法变成对象的属性
    def calculate(self):
        return self.a + self.b + self.c +self.d
abcd = Graphics(1, 2, 3, 4)
print(abcd.calculate) #调用属性后面不用圆括号，调用方法要加括号
```

## 继承与多态

面向对象有三大目的：封装、继承与多态。封装是隐藏细节，只暴露外部接口。前面做的所有事都是封装，
调用方法时，不需要关注方法的实现细节，只需要调用就行了。

面向对象允许在已有类的基础上创建新类，提供继承信息的类是父类，得到继承信息的类是子类，以下演示继承语法：

```python
class Human(object): #定义父类，object是所有类的父类，可以不写
    def __init__(self, name):
        self.n = name
    def eat(self, food):
        print(f'{self.n} are eating {food}')
class Student(Human): #定义子类，括号是其父类
    def __init__(self, name, age):
        super().__init__(name) #继承父类的属性
    def study(self, course):
        print(f'{self.n} are studying {course}')
one = Student(name, 18):
one.eat(poop) #对象可以调用父类方法
one.study(math) #对象也可以调用子类的方法
```

以上为继承语法，一个子类时显得多此一举，但多个子类时会十分有用

而多态的含义则是父类的同一方法，对于不用的子类有不同的实现思路，
而这个父类叫抽象类，通过abc模块一个名为ABCMeta的元类定义抽象类，元类是什么不用管，
多态语法如下：

```python
from abc import ABCMeta, abstractmethod #导入abc模块的ABCMeta元类和abstractmethod装饰器
class Human(metaclass=ABCMeta):
    def __init__(self, name):
        self.n = name
    def eat(self, food):
        print(f'{self.n} are eating {food}')
    @abstractmethod #用装饰器将work方法声明为抽象方法
    def work(self):
        pass #pass关键字跳过这部，把work方法交给子类重写
class Student(Human):
    def __init__(self, name, age):
        super().__init__(name)
    def work(self, course):
        print(f'{self.n} are studying {course}')
class Teacher(Human):
    def __init__(self, name):
        super().__init__(name)
    def work(self, title):
        print(f'{self.n} are teaching {title}')
one = Student('one', 18)
two = Teacher('two')
one.work('math')
two.work('math')
```

用isinstance(对象, 子类)函数可以判断对象是否属于某子类，输出布尔值
