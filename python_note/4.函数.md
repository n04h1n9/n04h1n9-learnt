# 函数

python的函数是一等函数，即函数可以赋值给变量，也可以作为函数的参数和返回值。同时函数具有无副作用设计，即除了返回返回值外，不对程序产生任何影响

## 定义函数

```python
def function(arg1, arg2): #arg是函数的参数（因变量）
    代码块 #函数的可执行部分，便于重复调用
    return something #something是函数值（一般叫返回值），可以不用写return
```

## ## 函数的参数

- 位置参数和关键字参数

位置参数：传参数时不指定位置，按顺序依次传入

关键字参数：传参数时无视参数位置，按`参数名 = 参数`的形式传入参数

演示如下：

```python
def judgement(a, b, c):
    return a + b > c and a + c > b and b + c > a
print(judgement(11, 45, 14)) #位置参数
print(judgement(c = 11, a = 45, b = 14)) #关键字参数
```

上面定义函数的代码如果在传参的时候在后面加/，即`(a, b, c, /)`的话，会强制位置参数。
同理，如果在前面加*的话，就会命名关键字参数（只能传关键字参数），如`(*, a, b, c)`

- 参数的默认值

上面的代码中，如果在定义函数时指定好参数，如`def judgement(a = 11, b, c)`,
传参的时候就可以只传两个，传三个位置参数的话，就会按照位置参数的规则传参

> 传关键字参数时，带默认值的参数必须放在不带参数值的参数之后

- 可变参数

调用参数时，如果可以传入0个或多个参数，那这些参数叫做可变参数，可以通过星号表达式让函数支持可变参数，
调用函数传入的参数会保存到一个元组，对其遍历即可得到各个参数

演示如下

```python
def add(*args): #对任意数求和
    total = 0
    for arg in args:
        if type(arg) in (int, float): #成员运算
            total += arg
    return total
```

如果想以“参数名+参数值的形式传入若干参数，可以添加可变关键字参数，将参数传入一个字典

演示如下(copy from python100天)：

```python
# 参数列表中的**kwargs可以接收0个或任意多个关键字参数
# 调用函数时传入的关键字参数会组装成一个字典（参数名是字典中的键，参数值是字典中的值）
# 如果一个关键字参数都没有传入，那么kwargs会是一个空字典
def foo(*args, **kwargs):
    print(args)
    print(kwargs)
foo(3, 2.1, True, name='骆昊', age=43, gpa=4.95)
#输出
# (3, 2.1, True)
# {'name': '骆昊', 'age': 43, 'gpa': 4.95}
```

## 模块

python中每个文件代表了一个模块，在不同模块中可以有同名的函数，
在使用函数时，用import关键字导入指定模块再使用完全限定名的调用方式（模块名.函数名），
就可以区分是哪个模块的函数，import关键字的用法如下：

```python
import time #导入time模块
from random import randomrange as rr #从random模块导入randomrange函数，并取别名为rr
```

> tip:如果用from-import关键字，如果不去别名或别名一样，那新导入的会覆盖旧导入的，
可以取不同别名来区分

## 标准库中的模块和函数

python标准库和第三方库集成了很多模块和函数，
pythom标准库中还有一些不需要import的函数，称为**内置函数**，
见[python字典](/python_note/python%E5%AD%97%E5%85%B8/5.%E9%83%A8%E5%88%86%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0.md)

## 高阶函数

像数学中的函数一样，python中的函数也可以嵌套，即a函数可以作为b函数的参数传入，这在python中被叫做高阶函数。
**调用函数需要在后面加圆括号，把函数作为参数传入不用加圆括号**。

## Lambda函数

Lambda函数没有名字，因此也被叫做匿名函数，其只能有一行代码，运算结果即位返回值，通常用于定义简单的函数，
用lambda关键字定义

演示如下：

```python
add = lambda b : b += 1 #定义一个后继运算函数
print(add(4)) #调用lambda函数
```

## 偏函数

偏函数是指固定函数的某些参数，生成一个新的函数，这样就无需在每次调用函数时都传递相同的参数。在 Python 语言中，
我们可以使用functools模块的partial函数来创建偏函数

```python
import functools

int2 = functools.partial(int, base=2)
int8 = functools.partial(int, base=8)
int16 = functools.partial(int, base=16)

print(int('1001'))    # 1001

print(int2('1001'))   # 9
print(int8('1001'))   # 513
print(int16('1001'))  # 4097
```

partial函数的第一个参数和返回值都是函数，它将传入的函数处理成一个新的函数返回。
通过构造偏函数，我们可以结合实际的使用场景将原函数变成使用起来更为便捷的新函数

## 装饰器

Python 语言中，装饰器是“用一个函数装饰另外一个函数并为其提供额外的能力”的语法现象，
装饰器本身是一个高阶函数，其参数和返回值都是函数，装饰器写法如下：

```python
def bag(func):
    def wrapper(*args, **kargs):
        something #修饰部分
        result = func(*args, **kargs)
        return result
    return wrapper
```

调用装饰器时，使用一种叫语法糖的语法,具体演示如下：

```python
@bag #语法糖，用@装饰器以调用，如果有多个装饰器，则从下往上调用
def fuck_zj(hyw):
    something #被装饰函数内容
```

在代码的某些地方，如果像去掉装饰器的作用执行原函数，
可以使用functools模块中的wraps函数,它也是个装饰器,可以在创建装饰器时放在wrapper函数之上，
这样在需要取消装饰器时，可以通过被装饰函数的__wrapped__属性获得被装饰之前的函数,演示如下：

```python
from functools import wraps as w
def bag(func):
    @w(func)
    def wrapper(*args, **kargs):
        something 
        result = func(*args, **kargs)
        return result
    return wrapper
fuck_zj(hyw) #保留装饰器功能的函数
fuck_zj.__wrapped__(hyw) #去掉装饰器功能的函数
```

## 递归调用

函数自己调用自己叫递归调用，导致函数停止调用自身的条件叫递归的收敛条件，递归次数太多会导致栈溢出，
通俗来讲就是死了,而且递归的速度很慢，以下是用递归调用写的求阶乘函数：

```python
def fac(num):
    if num in (0, 1): #收敛条件
        return 1 #if的返回值
    return num * fac(num - 1) #调用自己
```
